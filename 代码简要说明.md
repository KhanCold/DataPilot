# DataPilot 代码简要说明

## 1. 整体理念与设计

系统采用了分层、模块化的智能代理架构,主要借鉴了 **ReAct (Reasoning and Acting)** 的思想。

- **分层设计**: 系统分为**规划层**和**执行层**。

  - **规划层 (Planner)** 负责宏观的策略制定,将用户的高级、模糊的自然语言需求分解成清晰、可执行的逻辑步骤。
  - **执行层 (Worker)** 负责微观的操作执行,接收规划层下发的具体任务,并生成代码来完成它。

- **ReAct 模式**: 系统在两个层面应用了 ReAct 思想,实现了强大的自主纠错能力。
  - **微观纠错 (Worker ReAct Loop)**: `Worker` 在执行单个任务时,会进行“思考 -> 行动 -> 观察 -> 思考...”的循环。如果生成的代码执行出错,它会观察错误信息,然后重新思考、生成修正后的代码,并在一个设定的次数内（例如 3 次）反复尝试。
  - **宏观纠错 (Orchestrator Re-planning Loop)**: 如果 `Worker` 的微观纠错失败,或者整个计划执行完毕后,系统通过 `Orchestrator` 的验证模块发现最终结果并未完全解决用户问题,系统会启动**重新规划**。`Planner` 会接收到失败的上下文（包括错误信息或验证反馈）,从而生成一个全新的、更优的计划来纠正宏观层面的错误。

这种双重纠错循环使得 DataPilot 具备了强大的鲁棒性,能够自主地从代码执行错误和高层逻辑错误中恢复。

## 2. 核心模块分工

系统主要由以下几个核心模块组成：

### 2.1. Orchestrator (协调器)

`Orchestrator` 是整个系统的“大脑”和总指挥。它不直接参与具体的规划或代码生成,而是负责协调其他所有模块,管理从用户请求到最终答案的端到端流程。

- **职责**:
  - 初始化所有服务模块 (`Planner`, `Worker`, `StateManager`, `CodeExecutor`)。
  - 接收用户请求,启动整个分析流程。
  - 调用 `Planner` 生成初始计划。
  - 循环执行计划中的每一步,调用 `Worker` 来处理。
  - 监控计划执行状态,当 `Worker` 报告永久性失败时,调用 `Planner` 进行重新规划。
  - 在计划成功执行后,调用**验证模块**,评估分析结果是否完整、准确地回答了用户的问题。
  - 如果验证不通过,根据反馈再次触发重新规划。
  - 格式化并向用户呈现最终的分析报告,同时将结果保存为 Markdown 文件。

### 2.2. Planner (规划器)

`Planner` 扮演着“项目经理”的角色,负责高级任务的分解和规划。

- **职责**:
  - **生成计划 (`generate_plan`)**: 接收 `Orchestrator` 传递的用户请求和当前状态上下文（如已有的数据文件、DataFrame 摘要等）,调用 LLM 将其分解为一个由多个逻辑步骤组成的 JSON 格式计划。
  - **重新规划 (`replan`)**: 当执行失败或最终结果不满足要求时,`Planner` 会接收到包含错误信息或反馈的上下文,并据此生成一个全新的、旨在解决之前问题的计划。

### 2.3. Worker (执行器)

`Worker` 是“程序员”或“执行者”,负责执行 `Planner` 分配下来的单个具体任务。

- **职责**:
  - 接收一个明确的任务描述（例如：“计算 df_1 的‘销售额’列的总和”）。
  - 基于任务描述和详细的上下文（包括历史代码、DataFrame 状态等）,调用 LLM 生成完成该任务所需的 Python 代码。
  - 调用 `CodeExecutor` 在一个隔离的沙箱环境中执行生成的代码。
  - 内置**微观纠错循环**：如果代码执行失败,它会捕获错误,并带着错误信息再次请求 LLM 生成修正后的代码,进行重试。
  - 将执行成功的结果或最终无法解决的失败状态返回给 `Orchestrator`。

### 2.4. StateManager (状态管理器)

`StateManager` 是系统的“记忆中心”,负责记录和管理整个任务生命周期中的所有状态信息。

- **职责**:
  - 维护工作区 (`workspace`) 内的文件。
  - 记录用户与系统的交互历史,包括每一轮的用户查询、生成的计划、验证结果等。
  - 保存所有已成功执行的代码块。
  - 存储和更新代码执行环境中所有 DataFrame 的元信息摘要（如形状、列名、数据类型、头部样本等）。
  - 管理全局的 Prompt。

### 2.5. CodeExecutor (代码执行器)

`CodeExecutor` 提供一个安全的、有状态的沙箱环境,用于执行 `Worker` 生成的 Python 代码。它通过 `jupyter_client` 与一个独立的 `ipykernel` 内核通信,确保了代码执行的隔离性和状态的持久性。

## 3. 其他模块说明

- **`llm_api.py`**: 封装了与大型语言模型（LLM）的所有 API 交互。它负责向配置好的模型（ `qwen`）发送请求,并处理返回结果。它内置了重试机制以增加调用的稳定性,并能根据要求解析返回的 JSON 对象。

- **`custom_types.py`**: 定义了系统中使用的关键数据结构类型。

- **`debug_utils.py`**: 将 prompt 输入到`logs/prompts.log` 文件中,便于调试模型。

- **`workspace/`**: 一个目录,作为代码执行器的工作区。所有文件操作（如读取 CSV）都在此目录下进行,以确保路径的统一和环境的隔离。

- **`result/`**: 用于存放每次任务执行后生成的 Markdown 格式分析报告。

## 4. 系统整体流程

DataPilot 处理一个用户请求的完整流程如下：

1.  **初始化**: 用户输入一个数据分析请求。`Orchestrator` 接收请求,并初始化一个新的交互状态。
2.  **规划**: `Orchestrator` 调用 `Planner`,后者根据用户请求和当前系统状态（例如,工作区中已加载的 CSV 文件）生成一个初始的、分步骤的执行计划。
3.  **循环执行**: `Orchestrator` 开始按顺序执行计划中的步骤。
    a. 对于每一步,`Orchestrator` 调用 `Worker`。
    b. `Worker` 根据该步骤的任务描述生成 Python 代码。
    c. `Worker` 尝试执行代码。如果失败,它会在内部进行数次**微观纠错**（ReAct 循环）。
    d. 如果 `Worker` 最终成功,则将结果记录到 `StateManager`,`Orchestrator` 继续执行下一步。
    e. 如果 `Worker` 在多次尝试后仍失败,它会将失败状态报告给 `Orchestrator`。
4.  **重新规划 (如果需要)**: 如果任何步骤执行失败,`Orchestrator` 会暂停当前计划,并调用 `Planner` 的 `replan` 功能。`Planner` 会基于失败的上下文（错误日志）生成一个全新的计划,流程返回第 3 步,从新计划的第一个步骤开始执行。
5.  **验证**: 当所有计划步骤都成功执行后,`Orchestrator` 进入验证阶段。它会调用 LLM 来评估整个执行过程和最终结果是否全面回答了用户的原始问题。
6.  **再次重新规划 (如果需要)**:
    a. 如果验证结果为 `incomplete`,说明分析尚有不足。`Orchestrator` 会将验证模型给出的“原因”作为错误信息,再次触发**重新规划**,流程返回第 4 步。
    b. 如果验证结果为 `complete`,说明任务成功完成。
7.  **结果呈现**: `Orchestrator` 整合验证模型生成的最终摘要,向用户展示分析报告,并将详细过程（最终答案、执行摘要、完整脚本）保存到 `result/task-N.md` 文件中。
8.  **结束**: 任务完成。
