import os
import shutil
import json
from typing import List, Dict, Optional

from custom_types import AllSummaries, DataFrameSummary, Plan, PlanStep


class StateManager:
    """
    管理系统的状态,包括工作区文件、对话历史和 DataFrame 摘要。
    这是系统的"记忆"。
    """
    def __init__(self, workspace_dir: str = "./workspace"):
        """
        初始化 StateManager。

        Args:
            workspace_dir (str): 用于存放和管理文件的工作区目录。
        """
        self.workspace_dir = workspace_dir
        if not os.path.exists(self.workspace_dir):
            os.makedirs(self.workspace_dir)
        
        # --- Core State Components ---

        # The user's original, top-level request.
        self.user_query: Optional[str] = None

        # The execution plan generated by the Planner.
        self.plan: Plan = []

        # A sequential log of all successfully executed code blocks.
        self.executed_code_blocks: List[str] = []

        # Conversation history, storing user-assistant interactions.
        self.conversation_history: List[Dict[str, str]] = []

        # DataFrame summaries, storing metadata of all DataFrames in the kernel.
        self.dataframe_summaries: AllSummaries = {}

    def _format_summary_for_llm(self, summary: DataFrameSummary) -> str:
        """Formats a single DataFrame summary into a string for the LLM context."""
        if "error" in summary:
            return f"  - Error fetching summary: {summary['error']}"

        shape = summary.get('shape', 'N/A')
        columns = summary.get('columns_and_dtypes', {})
        head_sample = summary.get('head_sample', 'N/A')

        col_str_parts = []
        for col, dtype in columns.items():
            col_str_parts.append(f"{col} ({dtype})")
        
        return (
            f"  - Shape: {shape}\n"
            f"  - Columns: [{', '.join(col_str_parts)}]\n"
            f"  - Head Sample:\n```csv\n{head_sample}```"
        )

    def set_user_query(self, query: str):
        """Sets the initial user query."""
        self.user_query = query

    def set_plan(self, plan: Plan):
        """Sets the execution plan."""
        self.plan = plan

    def add_executed_code_block(self, code: str):
        """Adds a successfully executed code block to the history."""
        self.executed_code_blocks.append(code)

    def update_plan_step_status(self, step_id: int, status: str):
        """Updates the status of a specific plan step."""
        for step in self.plan:
            if step["step_id"] == step_id:
                step["status"] = status
                break

    def load_csvs(self, user_file_paths: List[str]):
        """
        将用户提供的 CSV 文件复制到工作区目录。

        Args:
            user_file_paths (List[str]): 用户提供的 CSV 文件路径列表。
        """
        for file_path in user_file_paths:
            if os.path.exists(file_path) and file_path.endswith('.csv'):
                try:
                    shutil.copy(file_path, self.workspace_dir)
                except Exception as e:
                    print(f"Error loading file {file_path}: {e}")
            else:
                print(f"Warning: File not found or not a CSV, skipping: {file_path}")

    def update_conversation_history(self, role: str, content: str):
        """
        向对话历史中添加一条新消息。

        Args:
            role (str): 消息的角色 ("user" 或 "assistant")。
            content (str): 消息的内容。
        """
        self.conversation_history.append({"role": role, "content": content})

    def update_all_dataframe_summaries(self, summaries_dict: AllSummaries):
        """
        全量替换当前的 DataFrame 摘要。
        这个方法由 Worker 在 CodeExecutor 执行代码并获取最新状态后调用。

        Args:
            summaries_dict (AllSummaries): 从内核获取的新的 DataFrame 摘要字典。
        """
        self.dataframe_summaries = summaries_dict

    def get_workspace_files(self) -> List[str]:
        """
        获取工作区目录下的所有文件名。

        Returns:
            List[str]: 文件名列表。
        """
        try:
            return [f for f in os.listdir(self.workspace_dir) if os.path.isfile(os.path.join(self.workspace_dir, f))]
        except FileNotFoundError:
            return []

    def get_planner_context(self) -> str:
        """
        Assembles a concise context string specifically for the Planner.
        This context includes only the high-level information needed for planning.
        """
        context_parts = []

        # 1. Add workspace file list
        files_str = "\n".join([f"`{f}`" for f in self.get_workspace_files()])
        context_parts.append(f"\n**Workspace Files:**\n{files_str}")

        # 2. Add DataFrame summaries
        if self.dataframe_summaries:
            context_parts.append("\n**DataFrame Summaries in Sandbox:**")
            for df_name, summary in self.dataframe_summaries.items():
                formatted_summary = self._format_summary_for_llm(summary)
                context_parts.append(f"- `{df_name}`:\n{formatted_summary}\n")
        
        return "\n".join(context_parts)

    def get_worker_context(self, current_step: PlanStep) -> str:
        """
        Assembles a detailed, structured context string for the Worker.
        This provides the Worker with all the necessary information to execute a single step.
        """
        context_parts = []

        # 1. Overall Goal
        context_parts.append(f"**User's Goal:**\n{self.user_query}")

        # 2. Full Plan and Current Step
        plan_str = []
        for step in self.plan:
            prefix = "==>" if step['step_id'] == current_step['step_id'] else "   "
            status = step.get('status', 'pending')
            plan_str.append(f"{prefix} Step {step['step_id']} ({status}): {step['task']}")
        context_parts.append(f"\n**Full Plan (you are on Step {current_step['step_id']}):**\n" + "\n".join(plan_str))

        # 3. Previously Executed Code
        if self.executed_code_blocks:
            code_history = "\n".join(
                [f"```python\n{code}\n```" for code in self.executed_code_blocks]
            )
            context_parts.append(
                "\n**Code Executed So Far:**\n"
                "The following code blocks have been successfully executed in the sandbox. "
                "Do not repeat them. You can assume their variables (e.g., DataFrames) are available.\n"
                f"{code_history}"
            )
        else:
            context_parts.append("\n**Code Executed So Far:**\nNo code has been executed yet.")

        # 4. Workspace Files
        files_str = "\n".join([f"`{f}`" for f in self.get_workspace_files()])
        context_parts.append(f"\n**Workspace Files:**\n{files_str}")

        # 5. DataFrame Summaries
        if self.dataframe_summaries:
            context_parts.append("\n**Current DataFrame Summaries in Sandbox:**")
            for df_name, summary in self.dataframe_summaries.items():
                formatted_summary = self._format_summary_for_llm(summary)
                context_parts.append(f"- `{df_name}`:\n{formatted_summary}\n")
        
        return "\n".join(context_parts)

    def get_dataframe_summaries_for_display(self) -> str:
        """
        获取一个用于向用户展示的、格式化的 DataFrame摘要字符串。
        """
        if not self.dataframe_summaries:
            return "No data loaded yet."
        
        output = ["Data loaded successfully. Here are the summaries:"]
        for name, summary in self.dataframe_summaries.items():
            output.append(f"\n--- DataFrame: {name} ---")
            # Pretty print the summary dictionary for user display
            output.append(json.dumps(summary, indent=2, ensure_ascii=False))
        return "\n".join(output)

if __name__ == '__main__':
    # 测试 StateManager
    # Test StateManager
    pass
